import type { Plugin } from 'vite';
import { paths } from '../utils/paths.js';
import Logger from '../utils/logger.js';
import fs from 'fs-extra';
import path from 'node:path';

interface MessageType {
  type: string;
  payload?: any;
  response?: any;
}

interface StorageType {
  key: string;
  value: any;
}

/**
 * Parse TypeScript/JavaScript code to extract message types
 * This is a simplified version - a full implementation would use
 * the TypeScript Compiler API for accurate type extraction
 */
function extractMessageTypes(code: string, filePath: string): MessageType[] {
  const messages: MessageType[] = [];
  
  // Pattern to match chrome.runtime.sendMessage calls
  const sendMessagePattern = /chrome\.runtime\.sendMessage\s*\(\s*({[^}]+})/g;
  
  let match;
  
  // Extract sendMessage calls
  while ((match = sendMessagePattern.exec(code)) !== null) {
    try {
      // This is a simplified extraction - real implementation would use AST
      const messageStr = match[1];
      if (messageStr && messageStr.includes('type:')) {
        const typeMatch = messageStr.match(/type:\s*['"`]([^'"`]+)['"`]/);
        if (typeMatch && typeMatch[1]) {
          messages.push({
            type: typeMatch[1],
            payload: {}, // Would extract actual payload structure
          });
          Logger.debug(`Found message type: ${typeMatch[1]} in ${filePath}`);
        }
      }
    } catch (e) {
      // Ignore parsing errors in this simplified version
    }
  }
  
  return messages;
}

/**
 * Parse code to extract storage types
 */
function extractStorageTypes(code: string, filePath: string): StorageType[] {
  const storageTypes: StorageType[] = [];
  
  // Pattern to match storage.set calls
  const storageSetPattern = /chrome\.storage\.(local|sync)\.set\s*\(\s*[{']([^'}]+)/g;
  
  let match;
  while ((match = storageSetPattern.exec(code)) !== null) {
    try {
      const key = match[2];
      if (key) {
        storageTypes.push({
          key,
          value: {}, // Would extract actual value type
        });
        Logger.debug(`Found storage key: ${key} in ${filePath}`);
      }
    } catch (e) {
      // Ignore parsing errors
    }
  }
  
  return storageTypes;
}

/**
 * Generate TypeScript declaration file
 */
function generateTypeDeclarations(messages: MessageType[], storage: StorageType[]): string {
  let declarations = `// Auto-generated types for browser extension messaging and storage
// Generated by @browser-ext/core

declare namespace BrowserExt {
  // Message types
  export type MessageType = 
`;

  if (messages.length > 0) {
    const uniqueTypes = [...new Set(messages.map(m => m.type))];
    declarations += uniqueTypes.map(type => `    | '${type}'`).join('\n') + ';\n\n';
    
    declarations += `  // Message type map
  export interface MessageMap {\n`;
    uniqueTypes.forEach(type => {
      declarations += `    '${type}': {
      type: '${type}';
      payload?: any; // TODO: Extract actual payload type
      response?: any; // TODO: Extract actual response type
    };\n`;
    });
    declarations += '  }\n\n';
  } else {
    declarations += '    | never;\n\n';
    declarations += '  export interface MessageMap {}\n\n';
  }

  // Storage types
  if (storage.length > 0) {
    declarations += `  // Storage keys
  export interface StorageSchema {\n`;
    const uniqueKeys = [...new Set(storage.map(s => s.key))];
    uniqueKeys.forEach(key => {
      declarations += `    '${key}': any; // TODO: Extract actual value type\n`;
    });
    declarations += '  }\n';
  } else {
    declarations += '  export interface StorageSchema {}\n';
  }

  declarations += `}

// Type augmentation for chrome.runtime
declare global {
  namespace chrome.runtime {
    function sendMessage<T extends keyof BrowserExt.MessageMap>(
      message: BrowserExt.MessageMap[T]
    ): Promise<BrowserExt.MessageMap[T]['response']>;
    
    function sendMessage<T extends keyof BrowserExt.MessageMap>(
      extensionId: string,
      message: BrowserExt.MessageMap[T]
    ): Promise<BrowserExt.MessageMap[T]['response']>;
    
    const onMessage: {
      addListener<T extends keyof BrowserExt.MessageMap>(
        callback: (
          message: BrowserExt.MessageMap[T],
          sender: chrome.runtime.MessageSender,
          sendResponse: (response: BrowserExt.MessageMap[T]['response']) => void
        ) => boolean | void
      ): void;
    };
  }
  
  namespace chrome.storage {
    interface StorageArea {
      get<K extends keyof BrowserExt.StorageSchema>(
        keys: K | K[]
      ): Promise<Pick<BrowserExt.StorageSchema, K>>;
      
      set<K extends keyof BrowserExt.StorageSchema>(
        items: Partial<Pick<BrowserExt.StorageSchema, K>>
      ): Promise<void>;
    }
  }
}

export {};
`;

  return declarations;
}

/**
 * Vite plugin for automatic type inference
 */
export function browserExtTypeInferencePlugin(): Plugin {
  const allMessages: MessageType[] = [];
  const allStorage: StorageType[] = [];
  let hasAnalyzed = false;

  return {
    name: 'browser-ext:type-inference',
    
    enforce: 'pre',
    
    transform(code, id) {
      // Only analyze TypeScript/JavaScript files
      if (!id.match(/\.(ts|tsx|js|jsx)$/) || id.includes('node_modules')) {
        return null;
      }

      // Extract types from the code
      const messages = extractMessageTypes(code, id);
      const storage = extractStorageTypes(code, id);
      
      if (messages.length > 0) {
        allMessages.push(...messages);
      }
      
      if (storage.length > 0) {
        allStorage.push(...storage);
      }

      // No transformation needed
      return null;
    },

    generateBundle() {
      if (!hasAnalyzed && (allMessages.length > 0 || allStorage.length > 0)) {
        hasAnalyzed = true;
        
        // Generate type declarations
        const declarations = generateTypeDeclarations(allMessages, allStorage);
        
        // Write to browser-ext.d.ts in the project root
        const typesPath = path.join(paths.root, 'browser-ext.d.ts');
        fs.writeFileSync(typesPath, declarations);
        
        Logger.success(`Generated type definitions: browser-ext.d.ts`);
        Logger.info(`Found ${allMessages.length} message types and ${allStorage.length} storage keys`);
        
        // Also emit to dist for reference
        this.emitFile({
          type: 'asset',
          fileName: 'browser-ext.d.ts',
          source: declarations,
        });
      }
    },
    
    watchChange(id) {
      // Reset analysis when files change
      if (!id.includes('node_modules') && id.match(/\.(ts|tsx|js|jsx)$/)) {
        hasAnalyzed = false;
      }
    },
  };
}